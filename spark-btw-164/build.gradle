import net.fabricmc.loom.task.RemapJarTask
import net.fabricmc.loom.api.processor.MinecraftJarProcessor
import net.fabricmc.loom.api.processor.ProcessorContext
import net.fabricmc.loom.api.processor.SpecContext

import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption

buildscript {
    repositories {
        mavenCentral()
        maven {
            url 'https://BTW-Community.github.io/BTW-gradle'
        }
        maven {
            name = 'Jitpack'
            url = 'https://jitpack.io'
        }
    }
}

plugins {
    id 'fabric-loom' version "1.4-SNAPSHOT"
    id 'com.gradleup.shadow' version '8.3.0'
}

tasks.withType(JavaCompile) {
    // override, compile targeting J21 todo is this right?
    options.release = 17
}

repositories {
    maven {
        name = 'legacy-fabric'
        url = 'https://maven.legacyfabric.net'
    }
    // Fixed LWJGL on Linux
    maven {
        name = 'Babric'
        url = 'https://maven.glass-launcher.net/babric'
    }
    maven {
        url 'https://BTW-Community.github.io/BTW-gradle'
    }
    maven {
        url file('mavenRepo')
    }
    mavenCentral() //For fastutil
//    maven { url 'https://maven.fabricmc.net/' }
//    maven {
//        url 'https://maven.nucleoid.xyz/'
//        content {
//            includeGroup('eu.pb4')
//        }
//    }
    mavenLocal()
}

loom {
    setIntermediaryUrl('https://maven.legacyfabric.net/net/legacyfabric/intermediary/%1$s/intermediary-%1$s-v2.jar');
//    accessWidenerPath = file('src/main/resources/spark.aw')
    addMinecraftJarProcessor(
            BTWJarReplacer, "BTWJarReplacer", projectDir.toString()
    )
}

configurations {
    shade
    implementation.extendsFrom shade
}

def lwjglVersion = System.getProperty("os.name").toLowerCase().contains("mac") ? "2.9.1" : "2.9.0"

dependencies {
    // https://modmuss50.me/fabric.html
    minecraft 'com.mojang:minecraft:1.6.4'
    mappings "btw.community:mappings:1.0.3"
    modImplementation 'net.fabricmc:fabric-loader:0.14.19'

    implementation 'net.fabricmc:fabric-loom:1.4-SNAPSHOT'

    implementation 'org.apache.logging.log4j:log4j-core:2.19.0'
    implementation 'org.apache.logging.log4j:log4j-api:2.19.0'

    implementation "org.lwjgl.lwjgl:lwjgl_util:${lwjglVersion}"
    implementation "org.lwjgl.lwjgl:lwjgl:${lwjglVersion}"
    implementation "org.lwjgl.lwjgl:lwjgl-platform:${lwjglVersion}"

    implementation fileTree(dir: "libs", include: "**.zip")

    implementation 'com.google.guava:guava:14.0.1'

    // This is what MC 1.6 uses
    implementation 'com.google.code.gson:gson:2.2.2'

    implementation group: 'it.unimi.dsi', name: 'fastutil', version: '8.5.12'

//    Set<String> apiModules = [
//            "fabric-api-base",
//            "fabric-command-api-v2",
//            "fabric-lifecycle-events-v1"
//    ]
//
//    // Add each module as a dependency
//    apiModules.forEach {
//        modImplementation(fabricApi.module(it, '0.127.0+1.21.6'))
//    }
//
//    include(modImplementation('me.lucko:fabric-permissions-api:0.4.0'))
//
//    modImplementation('eu.pb4:placeholder-api:2.7.0+1.21.6')

    shade project(':spark-common')
}

processResources {
    inputs.property 'version', project.version

    from(sourceSets.main.resources.srcDirs) {
        include 'fabric.mod.json'
        expand (
                'pluginVersion': project.pluginVersion,
                'pluginDescription': project.pluginDescription
        )
    }

    from(sourceSets.main.resources.srcDirs) {
        exclude 'fabric.mod.json'
    }
}

license {
    exclude '**/smap/SourceMap.java'
}

shadowJar {
    archiveFileName = "spark-btw-${project.pluginVersion}-dev.jar"
    configurations = [project.configurations.shade]

    relocate 'net.kyori.adventure', 'me.lucko.spark.lib.adventure'
    relocate 'net.kyori.examination', 'me.lucko.spark.lib.adventure.examination'
    relocate 'net.kyori.option', 'me.lucko.spark.lib.adventure.option'
    relocate 'net.bytebuddy', 'me.lucko.spark.lib.bytebuddy'
    relocate 'com.google.protobuf', 'me.lucko.spark.lib.protobuf'
//    relocate 'org.objectweb.asm', 'me.lucko.spark.lib.asm'
    relocate 'one.profiler', 'me.lucko.spark.lib.asyncprofiler'
    relocate 'me.lucko.bytesocks.client', 'me.lucko.spark.lib.bytesocks'
    relocate 'org.java_websocket', 'me.lucko.spark.lib.bytesocks.ws'

    project.applyExcludes(delegate)

    dependencies {
        exclude(dependency('org.ow2.asm::'))
    }
}

task remappedShadowJar(type: RemapJarTask) {
    dependsOn tasks.shadowJar
    input = tasks.shadowJar.archiveFile
    addNestedDependencies = true
    archiveFileName = "spark-${project.pluginVersion}-btw.jar"
}

tasks.assemble.dependsOn tasks.remappedShadowJar

artifacts {
    archives remappedShadowJar
    shadow shadowJar
}

class BTWJarReplacer implements MinecraftJarProcessor<Spec> {
    String name
    String path

    @javax.inject.Inject
    BTWJarReplacer(String name, String path) {
        this.name = name
        this.path = path
    }

    @Override
    Spec buildSpec(SpecContext context) {
        return new Spec(path)
    }

    @Override
    void processJar(java.nio.file.Path jar, Spec spec, ProcessorContext context) throws IOException {
        // Replace the Minecraft jar with the custom one from BTW_dev.
        // This is just a straight up file replacement, no remapping or anything.
        if (!Files.exists(Paths.get(path, "build_BTW/BTW_dev/BTW_dev.zip"))) {
            // Print a warning if the BTW_dev zip doesn't exist.
            System.err.println("BTW_dev zip not found, skipping BTWJarReplacer")
        } else {
            System.out.println("BTW_dev zip found, replacing Minecraft jar with BTW_dev jar.")
            Files.copy(Paths.get(path, "build_BTW/BTW_dev/BTW_dev.zip"), jar, StandardCopyOption.REPLACE_EXISTING)
            // Add Javadocs
            Files.copy(Paths.get(path, "build_BTW/BTW_dev/BTW_dev-javadoc.jar"), jar.resolveSibling(jar.getFileName().toString().replace(".jar", "-javadoc.jar")), StandardCopyOption.REPLACE_EXISTING)
        }
    }

    @Override
    String getName() {
        return name
    }

    class Spec implements MinecraftJarProcessor.Spec {
        String path

        Spec(String path) {
            this.path = path
        }

        @Override
        int hashCode() {
            if (!Files.exists(Paths.get(path, "build_BTW/BTW_dev/BTW_dev.zip"))) {
                return name.hashCode()
            } else {
                return Files.getLastModifiedTime(Paths.get(path, "build_BTW/BTW_dev/BTW_dev.zip")).hashCode() ^ name.hashCode()
            }
        }
    }
}